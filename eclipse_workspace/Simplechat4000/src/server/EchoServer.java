package server;import java.io.*;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.*;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {		// Class variables ************************************************	  /**	   * The string sent to the observers when a client has connected.	   */	  public static final String CLIENT_CONNECTED= "#OS:Client connected.";	  /**	   * The string sent to the observers when a client has disconnected.	   */	  public static final String CLIENT_DISCONNECTED= "#OS:Client disconnected.";	  /**	   * The string sent to the observers when an exception occurred with a client.	   * The error message of that exception will be appended to this string.	   */	  public static final String CLIENT_EXCEPTION= "#OS:Client exception.";	  /**	   * The string sent to the observers when a listening exception occurred.	   * The error message of that exception will be appended to this string.	   */	  public static final String LISTENING_EXCEPTION= "#OS:Listening exception.";	  /**	   * The string sent to the observers when the server has closed.	   */	  public static final String SERVER_CLOSED= "#OS:Server closed.";	  /**	   * The string sent to the observers when the server has started.	   */	  public static final String SERVER_STARTED= "#OS:Server started.";	  /**	   * The string sent to the observers when the server has stopped.	   */	  public static final String SERVER_STOPPED= "#OS:Server stopped.";	  	// Constructors ****************************************************	ObservableServer server;	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port) {		server = new ObservableOriginatorServer(port);		server.addObserver(this);	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg    The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		if (msg instanceof String && ((String) msg).startsWith("#")) {			if (msg.equals("#logoff")) {				try {					client.close();				} catch (IOException e) {					e.printStackTrace();				}			} else if (((String) msg).startsWith("#login")) {				String[] tab = ((String) msg).split(" ");				client.setInfo("id", tab[1]);			}		} else {			System.out.println("Message received from " + client.getInfo("id") + " : " + msg);			server.sendToAllClients((String) client.getInfo("id") + " " + msg);		}	}	public void handleMessageFromServerUI(String message) {		if (message instanceof String && ((String) message).startsWith("#")) {			if (message.equals("#quit")) {				server.stopListening();				try {					server.close();				} catch (IOException e) {					e.printStackTrace();				}				System.exit(0);			} else if (message.equals("#stop")) {				System.out.println("Ok i stop");				server.stopListening();			} else if (message.equals("#close")) {				server.stopListening();				try {					server.close();				} catch (IOException e) {					e.printStackTrace();				}			} else if (message.startsWith("#setport")) {				String[] tab = message.split(" ");				server.setPort(Integer.parseInt(tab[1]));			} else if (message.equals("#start")) {				try {					server.listen();				} catch (IOException e) {					e.printStackTrace();				}			} else if (message.equals("#getport")) {				System.out.println(server.getPort());			}		} else {			server.sendToAllClients("SERVER MSG > " + message);		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		System.out.println("Server listening for connections on port " + server.getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void clientConnected(ConnectionToClient client) {		System.out.println("Client connected as " + client.getInfo("id"));	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	synchronized protected void clientDisconnected(ConnectionToClient client) {		System.err.println("Client disconnected");	}	synchronized protected void clientException(ConnectionToClient client, Throwable exception) {		System.err.println("Client Exception error");	}	/**	 * This method overrides the one in the superclass. Called when the server stops	 * listening for connections.	 */	protected void serverStopped() {		System.out.println("Server has stopped listening for connections.");	}	public void update(Observable arg0, Object arg1) {		if (arg1 instanceof OriginatorMessage && ((OriginatorMessage)arg1).getMessage() instanceof String) {			String msg = ((OriginatorMessage)arg1).getMessage().toString();			System.out.println(msg);			ConnectionToClient client = ((OriginatorMessage)arg1).getOriginator();			if (msg.equals(CLIENT_CONNECTED)) {				System.out.println("Client connected : " + client.getInfo("id"));			} else if (msg.equals(CLIENT_DISCONNECTED)) {				System.out.println("Client disconnected : " + client.getInfo("id"));			} else if (msg.equals(CLIENT_EXCEPTION)) {				System.out.println("Client exception : " + client.getInfo("id"));			} else if (arg1.toString().equals(SERVER_CLOSED)) {				System.out.println("The server is closed");			} else if (arg1.toString().equals(SERVER_STARTED)) {				System.out.println("The server started");			} else if (arg1.toString().equals(SERVER_STOPPED)) {				System.out.println("The server stopped");			}		} else if (arg1 instanceof Exception) {			System.err.println(((Exception)arg1).getMessage());		}		else {			Object msg = ((OriginatorMessage)arg1).getMessage();			ConnectionToClient client = ((OriginatorMessage)arg1).getOriginator();			handleMessageFromClient(msg, client);		}	}		public void listen() {		try {			server.listen();		} catch (IOException e) {			e.printStackTrace();		}	}}//End of EchoServer class